"""
MiniF2F benchmark implementation using the generic Lean Bench SDK.

This module demonstrates how to use the SDK for MiniF2F-specific tasks while
keeping all the benchmark-specific logic separate from the core SDK.
"""

import re
import subprocess

# Import from the core SDK
import sys
from pathlib import Path
from typing import Any

sys.path.append(str(Path(__file__).parent.parent.parent / "src"))

from lean_bench.cache import cache_compilation_result, store_cached_result
from lean_bench.compiler import compile_lean_content
from lean_bench.project import setup_lean_project
from lean_bench.storage import store_compilation_attempt

# Constants for MiniF2F
DEFAULT_MINIF2F_REPO_URL = "https://github.com/openai/miniF2F"
MINIF2F_IMPORT_HEADER = """-- Autogenerated MiniF2F theorem compilation
import minif2f_import

open_locale nat
open_locale real
open_locale rat
open_locale big_operators
open_locale topological_space

"""


class MiniF2FEnvironment:
    """
    MiniF2F environment manager using the generic SDK.
    """

    def __init__(self, base_path: Path | str = "~/.lean-bench/minif2f"):
        self.base_path = Path(base_path).expanduser()
        # MiniF2F structure: base_path contains the cloned repo
        self.lean_path = self.base_path / "lean"
        self.src_path = self.lean_path / "src"

    def is_setup(self) -> bool:
        """Check if MiniF2F environment is properly set up."""
        required_files = [
            self.base_path / "leanpkg.toml",  # Root leanpkg.toml
            self.lean_path / "src" / "minif2f_import.lean",
            self.lean_path / "src" / "test.lean",
            self.lean_path / "src" / "valid.lean",
        ]
        return all(f.exists() for f in required_files)

    def setup(self) -> bool:
        """
        Set up MiniF2F environment by cloning the repository and setting up dependencies.
        """
        if self.is_setup():
            return True

        try:
            # Create parent directory
            self.base_path.parent.mkdir(parents=True, exist_ok=True)
            
            # Clone MiniF2F repository if it doesn't exist
            if not self.base_path.exists():
                print(f"Cloning MiniF2F repository to {self.base_path}")
                result = subprocess.run(
                    ["git", "clone", "--depth", "1", DEFAULT_MINIF2F_REPO_URL, str(self.base_path)],
                    capture_output=True,
                    text=True,
                    timeout=300
                )
                if result.returncode != 0:
                    print(f"Failed to clone MiniF2F: {result.stderr}")
                    return False

            # Configure the Lean project
            print("Configuring MiniF2F Lean project...")
            result = subprocess.run(
                ["leanpkg", "configure"],
                cwd=str(self.base_path),
                capture_output=True,
                text=True,
                timeout=60
            )
            if result.returncode != 0:
                print(f"leanpkg configure failed: {result.stderr}")
                return False

            # Get mathlib cache for faster compilation
            print("Getting mathlib cache...")
            try:
                result = subprocess.run(
                    ["leanproject", "get-mathlib-cache"],
                    cwd=str(self.base_path),
                    capture_output=True,
                    text=True,
                    timeout=300
                )
                if result.returncode != 0:
                    print(f"Warning: mathlib cache setup failed: {result.stderr}")
                    # Continue anyway, compilation will just be slower
            except Exception as e:
                print(f"Warning: Could not get mathlib cache: {e}")

            # Verify setup
            if not self.is_setup():
                print("Setup completed but verification failed")
                return False

            print("MiniF2F environment setup completed successfully")
            return True

        except Exception as e:
            print(f"MiniF2F setup failed: {e}")
            return False

    def get_split_files(self) -> dict[str, Path]:
        """Get paths to the different split files."""
        return {
            "test": self.src_path / "test.lean",
            "valid": self.src_path / "valid.lean",
        }


def setup_minif2f(base_path: Path | str = "~/.lean-bench/minif2f") -> bool:
    """
    Set up MiniF2F environment using the SDK.

    Args:
        base_path: Directory where MiniF2F should be set up

    Returns:
        True if setup succeeded
    """
    env = MiniF2FEnvironment(base_path)
    return env.setup()


def get_theorem_list(
    split: str,
    minif2f_path: Path | str = "~/.lean-bench/minif2f"
) -> list[str]:
    """
    Get list of theorem names from a MiniF2F split.

    Args:
        split: Split name (test, valid)
        minif2f_path: Path to MiniF2F environment

    Returns:
        List of theorem names
    """
    env = MiniF2FEnvironment(minif2f_path)
    split_files = env.get_split_files()

    if split not in split_files:
        return []

    split_file = split_files[split]
    if not split_file.exists():
        return []

    try:
        content = split_file.read_text(encoding="utf-8")
        # Extract theorem names using regex - looking for "theorem name"
        theorem_pattern = r"theorem\s+([a-zA-Z_][a-zA-Z0-9_]*)"
        theorems = re.findall(theorem_pattern, content)
        return theorems
    except Exception as e:
        print(f"Error reading {split_file}: {e}")
        return []


def extract_theorem_header(
    theorem_name: str,
    split: str,
    minif2f_path: Path | str = "~/.lean-bench/minif2f"
) -> str | None:
    """
    Extract the header (statement) of a specific theorem from MiniF2F.

    Args:
        theorem_name: Name of the theorem to extract
        split: Split name (test, valid)
        minif2f_path: Path to MiniF2F environment

    Returns:
        Theorem header string (theorem name ... :=) or None if not found
    """
    env = MiniF2FEnvironment(minif2f_path)
    split_files = env.get_split_files()

    if split not in split_files:
        return None

    split_file = split_files[split]
    if not split_file.exists():
        return None

    try:
        content = split_file.read_text(encoding="utf-8")
        
        # Extract theorem statement: "theorem name ... := sorry" or "theorem name ... := by ..."
        # We want everything up to ":="
        pattern = rf"(theorem\s+{re.escape(theorem_name)}\s+[^:]*:=)"
        match = re.search(pattern, content, re.DOTALL)
        
        if match:
            header = match.group(1).strip()
            return header
        
        return None
    except Exception as e:
        print(f"Error extracting theorem header for {theorem_name}: {e}")
        return None


def extract_theorem_proof_body(theorem_content: str) -> str | None:
    """
    Extract the proof body from theorem content.
    Handles various Lean proof formats: begin...end, by..., exact..., etc.

    Args:
        theorem_content: Full theorem content or just the proof part

    Returns:
        Proof body or None if not found
    """
    if not theorem_content:
        return None
    
    # Clean up the input
    content = theorem_content.strip()
    
    # Pattern 1: "begin ... end" proof
    begin_end_match = re.search(r"(begin\s+.*?end)", content, re.DOTALL)
    if begin_end_match:
        return begin_end_match.group(1).strip()

    # Pattern 2: "by ..." proof (single line or multi-line)
    by_match = re.search(r"(by\s+.*?)(?=\n\s*(?:theorem|lemma|def|$))", content, re.DOTALL)
    if by_match:
        return by_match.group(1).strip()

    # Pattern 3: "exact ..." proof
    exact_match = re.search(r"(exact\s+.*?)(?=\n\s*(?:theorem|lemma|def|$))", content, re.DOTALL)
    if exact_match:
        return exact_match.group(1).strip()

    # Pattern 4: Direct proof (just return the content if it looks like a proof)
    if any(keyword in content.lower() for keyword in ['simp', 'norm_num', 'ring', 'linarith', 'omega', 'tauto']):
        return content

    # If nothing matches, return the content as-is (might be a complete proof)
    return content


def compile_minif2f_theorem(
    theorem_content: str,
    theorem_name: str,
    split: str,
    minif2f_path: Path | str = "~/.lean-bench/minif2f",
    timeout: int = 60,
    store_attempt: bool = True
) -> dict[str, Any]:
    """
    Compile a MiniF2F theorem using the generic SDK.

    Args:
        theorem_content: The theorem proof content (e.g., "begin simp end")
        theorem_name: Name of the theorem to compile
        split: Dataset split (test, valid)
        minif2f_path: Path to MiniF2F environment
        timeout: Compilation timeout in seconds
        store_attempt: Whether to store the compilation attempt

    Returns:
        Dictionary with compilation results
    """
    env = MiniF2FEnvironment(minif2f_path)

    if not env.is_setup():
        return {
            "success": False,
            "error": "MiniF2F environment not set up. Run setup_minif2f() first."
        }

    # Extract theorem header from the original file
    theorem_header = extract_theorem_header(theorem_name, split, minif2f_path)
    if not theorem_header:
        return {
            "success": False,
            "error": f"Theorem '{theorem_name}' not found in split '{split}'"
        }

    # Extract and prepare the proof body
    proof_body = extract_theorem_proof_body(theorem_content)
    if not proof_body:
        return {
            "success": False,
            "error": "Could not extract valid proof from theorem_content"
        }

    # Prepare the full Lean content for compilation
    full_content = f"""{MINIF2F_IMPORT_HEADER}
{theorem_header}
{proof_body}
"""

    # Use SDK to compile the content
    try:
        # Check cache first
        cache_key, cached_result = cache_compilation_result(
            full_content,
            f"minif2f_{theorem_name}.lean",
            env.base_path,
            [],
            timeout
        )

        if cached_result:
            result_dict = dict(cached_result)
            result_dict["cached"] = True
        else:
            # Compile using SDK with the MiniF2F project root
            result = compile_lean_content(
                content=full_content,
                file_name=f"minif2f_{theorem_name}.lean",
                project_root=env.base_path,  # Use MiniF2F project root
                dependencies=None,  # Already included in content via imports
                timeout=timeout
            )

            # Convert to dictionary
            result_dict = {
                "success": result.success,
                "returncode": result.returncode,
                "stdout": result.stdout,
                "stderr": result.stderr,
                "timeout": result.timeout,
                "error": result.error,
                "duration_ms": result.duration_ms,
                "cached": False,
            }

            # Store in cache
            store_cached_result(cache_key, result_dict)

        # Add MiniF2F-specific metadata
        result_dict.update({
            "theorem_name": theorem_name,
            "split": split,
            "benchmark": "minif2f",
            "theorem_header": theorem_header,
            "proof_body": proof_body,
        })

        # Store attempt if requested
        if store_attempt:
            attempt_id = store_compilation_attempt(
                input_data={
                    "theorem_content": theorem_content,
                    "theorem_name": theorem_name,
                    "split": split,
                    "full_content": full_content,
                    "theorem_header": theorem_header,
                    "proof_body": proof_body,
                },
                output_data=result_dict,
                metadata={
                    "benchmark": "minif2f",
                    "theorem": theorem_name,
                    "split": split,
                }
            )
            result_dict["attempt_id"] = attempt_id

        return result_dict

    except Exception as e:
        error_result = {
            "success": False,
            "error": f"Compilation failed: {e!s}",
            "theorem_name": theorem_name,
            "split": split,
            "benchmark": "minif2f",
        }

        if store_attempt:
            attempt_id = store_compilation_attempt(
                input_data={
                    "theorem_content": theorem_content,
                    "theorem_name": theorem_name,
                    "split": split,
                },
                output_data=error_result,
                metadata={
                    "benchmark": "minif2f",
                    "theorem": theorem_name,
                    "split": split,
                }
            )
            error_result["attempt_id"] = attempt_id

        return error_result


def extract_theorem_body(theorem_content: str) -> str | None:
    """
    Extract the proof body from theorem content (for compatibility with existing code).

    Args:
        theorem_content: Full theorem content

    Returns:
        Proof body or None if not found
    """
    # Pattern to match "begin ... end" or "by ..." proofs
    begin_end_match = re.search(r"(begin.*?end)", theorem_content, re.DOTALL)
    if begin_end_match:
        return begin_end_match.group(1)

    by_match = re.search(r"(by\s+.*?)(?:\n|$)", theorem_content, re.DOTALL)
    if by_match:
        return by_match.group(1).strip()

    return None


def get_minif2f_stats(minif2f_path: Path | str = "~/.lean-bench/minif2f") -> dict[str, Any]:
    """
    Get statistics about the MiniF2F environment.

    Args:
        minif2f_path: Path to MiniF2F environment

    Returns:
        Dictionary with environment statistics
    """
    env = MiniF2FEnvironment(minif2f_path)

    if not env.is_setup():
        return {"setup": False, "error": "Environment not set up"}

    stats = {"setup": True}

    # Count theorems in each split
    for split in ["test", "valid", "train"]:
        theorems = get_theorem_list(split, minif2f_path)
        stats[f"{split}_theorems"] = len(theorems)

    # Get file information
    split_files = env.get_split_files()
    for split, file_path in split_files.items():
        if file_path.exists():
            stats[f"{split}_file_size"] = file_path.stat().st_size
        else:
            stats[f"{split}_file_size"] = 0

    return stats


# Backwards compatibility functions
def extract_theorem_body(theorem_content: str) -> str | None:
    """
    Extract the proof body from theorem content (for compatibility with existing code).
    This is an alias for extract_theorem_proof_body.

    Args:
        theorem_content: Full theorem content

    Returns:
        Proof body or None if not found
    """
    return extract_theorem_proof_body(theorem_content)


def lean_compile(theorem_content: str, theorem_name: str, split: str, data_path: str) -> dict[str, Any]:
    """
    Compatibility wrapper for the original lean_compile interface.
    
    Args:
        theorem_content: The theorem proof content
        theorem_name: Name of the theorem to compile
        split: Dataset split (test, valid)
        data_path: Path to MiniF2F environment
        
    Returns:
        Dictionary with compilation results
    """
    return compile_minif2f_theorem(
        theorem_content=theorem_content,
        theorem_name=theorem_name,
        split=split,
        minif2f_path=data_path
    )
