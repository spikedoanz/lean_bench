#!/usr/bin/env python3
import re
import subprocess
import tempfile
from pathlib import Path
from typing import Any

DEFAULT_MINIF2F_REPO_URL = "https://github.com/openai/miniF2F"
MINIF2F_IMPORT_HEADER = """-- Autogenerated MiniF2F theorem compilation
import minif2f_import

open_locale nat
open_locale real
open_locale rat
open_locale big_operators
open_locale topological_space

"""


class MiniF2FEnvironment:
    def __init__(self, base_path: Path | str = "~/.lean-bench/minif2f"):
        self.base_path = Path(base_path).expanduser()
        self.lean_path = self.base_path / "lean"
        self.src_path = self.lean_path / "src"

    def is_setup(self) -> bool:
        required_files = [
            self.base_path / "leanpkg.toml",
            self.lean_path / "src" / "minif2f_import.lean",
            self.lean_path / "src" / "test.lean",
            self.lean_path / "src" / "valid.lean",
        ]
        return all(f.exists() for f in required_files)

    def setup(self) -> bool:
        if self.is_setup():
            return True

        self.base_path.parent.mkdir(parents=True, exist_ok=True)
        
        if not self.base_path.exists():
            print(f"Cloning MiniF2F repository to {self.base_path}")
            result = subprocess.run(
                ["git", "clone", "--depth", "1", DEFAULT_MINIF2F_REPO_URL, str(self.base_path)],
                capture_output=True,
                text=True,
                timeout=300
            )
            if result.returncode != 0:
                print(f"Failed to clone MiniF2F: {result.stderr}")
                return False

        print("Configuring MiniF2F Lean project...")
        result = subprocess.run(
            ["leanpkg", "configure"],
            cwd=str(self.base_path),
            capture_output=True,
            text=True,
            timeout=60
        )
        if result.returncode != 0:
            print(f"leanpkg configure failed: {result.stderr}")
            return False

        print("Getting mathlib cache...")
        subprocess.run(
            ["leanproject", "get-mathlib-cache"],
            cwd=str(self.base_path),
            capture_output=True,
            text=True,
            timeout=300
        )

        return self.is_setup()

    def get_split_files(self) -> dict[str, Path]:
        return {
            "test": self.src_path / "test.lean",
            "valid": self.src_path / "valid.lean",
        }


def setup_minif2f(base_path: Path | str = "~/.lean-bench/minif2f") -> bool:
    env = MiniF2FEnvironment(base_path)
    return env.setup()


def get_theorem_list(split: str, minif2f_path: Path | str = "~/.lean-bench/minif2f") -> list[str]:
    env = MiniF2FEnvironment(minif2f_path)
    split_files = env.get_split_files()

    split_file = split_files.get(split)
    if not split_file or not split_file.exists():
        return []

    content = split_file.read_text(encoding="utf-8")
    theorem_pattern = r"theorem\s+([a-zA-Z_][a-zA-Z0-9_]*)"
    return re.findall(theorem_pattern, content)


def extract_theorem_header(
    theorem_name: str,
    split: str,
    minif2f_path: Path | str = "~/.lean-bench/minif2f"
) -> str | None:
    env = MiniF2FEnvironment(minif2f_path)
    split_files = env.get_split_files()

    split_file = split_files.get(split)
    if not split_file or not split_file.exists():
        return None

    content = split_file.read_text(encoding="utf-8")
    pattern = rf"(theorem\s+{re.escape(theorem_name)}\s+[^:]*:=)"
    match = re.search(pattern, content, re.DOTALL)
    return match.group(1).strip() if match else None


def extract_theorem_proof_body(theorem_content: str) -> str | None:
    content = theorem_content.strip()
    
    # "begin ... end" proof
    begin_end_match = re.search(r"(begin\s+.*?end)", content, re.DOTALL)
    if begin_end_match:
        return begin_end_match.group(1).strip()

    # "by ..." proof
    by_match = re.search(r"(by\s+.*?)(?=\n\s*(?:theorem|lemma|def|$))", content, re.DOTALL)
    if by_match:
        return by_match.group(1).strip()

    # "exact ..." proof
    exact_match = re.search(r"(exact\s+.*?)(?=\n\s*(?:theorem|lemma|def|$))", content, re.DOTALL)
    if exact_match:
        return exact_match.group(1).strip()

    # Direct proof tactics
    if any(keyword in content.lower() for keyword in ['simp', 'norm_num', 'ring', 'linarith', 'omega', 'tauto']):
        return content

    return content


def compile_minif2f_theorem(
    theorem_content: str,
    theorem_name: str,
    split: str,
    minif2f_path: Path | str = "~/.lean-bench/minif2f",
    timeout: int = 60
) -> dict[str, Any]:
    env = MiniF2FEnvironment(minif2f_path)

    if not env.is_setup():
        return {"success": False, "error": "MiniF2F environment not set up"}

    theorem_header = extract_theorem_header(theorem_name, split, minif2f_path)
    if not theorem_header:
        return {"success": False, "error": f"Theorem '{theorem_name}' not found in split '{split}'"}

    proof_body = extract_theorem_proof_body(theorem_content)
    if not proof_body:
        return {"success": False, "error": "Could not extract valid proof"}

    full_content = f"""{MINIF2F_IMPORT_HEADER}
{theorem_header}
{proof_body}
"""

    with tempfile.NamedTemporaryFile(mode='w', suffix='.lean', dir=env.src_path, delete=False) as f:
        f.write(full_content)
        temp_file = Path(f.name)

    try:
        result = subprocess.run(
            ["lean", "--json", str(temp_file)],
            cwd=str(env.base_path),
            capture_output=True,
            text=True,
            timeout=timeout
        )

        return {
            "success": result.returncode == 0,
            "returncode": result.returncode,
            "stdout": result.stdout,
            "stderr": result.stderr,
            "theorem_name": theorem_name,
            "split": split,
            "theorem_header": theorem_header,
            "proof_body": proof_body,
        }
    finally:
        temp_file.unlink(missing_ok=True)


def get_minif2f_stats(minif2f_path: Path | str = "~/.lean-bench/minif2f") -> dict[str, Any]:
    env = MiniF2FEnvironment(minif2f_path)

    if not env.is_setup():
        return {"setup": False}

    stats = {"setup": True}
    for split in ["test", "valid"]:
        theorems = get_theorem_list(split, minif2f_path)
        stats[f"{split}_theorems"] = len(theorems)

    return stats


# Tests
def test_setup():
    with tempfile.TemporaryDirectory() as temp_dir:
        test_path = Path(temp_dir) / "test_minif2f"
        env = MiniF2FEnvironment(test_path)
        
        assert not env.is_setup()
        success = env.setup()
        assert success
        assert env.is_setup()
        
        # Test idempotency
        success = env.setup()
        assert success
        print("✓ Setup test passed")


def test_theorem_list():
    with tempfile.TemporaryDirectory() as temp_dir:
        test_path = Path(temp_dir) / "test_minif2f"
        
        if not setup_minif2f(test_path):
            print("✗ Failed to setup MiniF2F for theorem list test")
            return
        
        test_theorems = get_theorem_list("test", test_path)
        valid_theorems = get_theorem_list("valid", test_path)
        
        assert len(test_theorems) > 0
        assert len(valid_theorems) > 0
        assert all(isinstance(t, str) for t in test_theorems)
        
        print(f"✓ Theorem list test passed (test: {len(test_theorems)}, valid: {len(valid_theorems)})")


def test_theorem_extraction():
    with tempfile.TemporaryDirectory() as temp_dir:
        test_path = Path(temp_dir) / "test_minif2f"
        
        if not setup_minif2f(test_path):
            print("✗ Failed to setup MiniF2F for extraction test")
            return
        
        theorems = get_theorem_list("test", test_path)
        if not theorems:
            print("✗ No theorems found for extraction test")
            return
        
        theorem_name = theorems[0]
        header = extract_theorem_header(theorem_name, "test", test_path)
        
        assert header is not None
        assert theorem_name in header
        assert "theorem" in header
        assert ":=" in header
        
        print(f"✓ Theorem extraction test passed for {theorem_name}")


def test_proof_body_extraction():
    test_cases = [
        ("begin simp end", "begin simp end"),
        ("by simp", "by simp"),
        ("exact h", "exact h"),
        ("norm_num", "norm_num"),
        ("begin\n  simp,\n  ring\nend", "begin\n  simp,\n  ring\nend"),
    ]
    
    for input_proof, expected in test_cases:
        result = extract_theorem_proof_body(input_proof)
        assert result == expected, f"Expected '{expected}', got '{result}'"
    
    print("✓ Proof body extraction test passed")


def test_compilation():
    with tempfile.TemporaryDirectory() as temp_dir:
        test_path = Path(temp_dir) / "test_minif2f"
        
        if not setup_minif2f(test_path):
            print("✗ Failed to setup MiniF2F for compilation test")
            return
        
        # Find a simple theorem to test
        theorems = get_theorem_list("test", test_path)
        if not theorems:
            print("✗ No theorems found for compilation test")
            return
        
        # Try compiling with "sorry" - should always work
        theorem_name = theorems[0]
        result = compile_minif2f_theorem("sorry", theorem_name, "test", test_path, timeout=30)
        
        assert "theorem_name" in result
        assert result["theorem_name"] == theorem_name
        assert "theorem_header" in result
        assert "proof_body" in result
        
        print(f"✓ Compilation test passed for {theorem_name}")


def test_stats():
    with tempfile.TemporaryDirectory() as temp_dir:
        test_path = Path(temp_dir) / "test_minif2f"
        
        # Before setup
        stats = get_minif2f_stats(test_path)
        assert not stats["setup"]
        
        # After setup
        if setup_minif2f(test_path):
            stats = get_minif2f_stats(test_path)
            assert stats["setup"]
            assert "test_theorems" in stats
            assert "valid_theorems" in stats
            assert stats["test_theorems"] > 0
            assert stats["valid_theorems"] > 0
            
            print(f"✓ Stats test passed: {stats}")


if __name__ == "__main__":
    import sys
    
    print("Running MiniF2F tests...")
    print("-" * 40)
    
    tests = [
        test_proof_body_extraction,
        test_setup,
        test_theorem_list,
        test_theorem_extraction,
        test_compilation,
        test_stats,
    ]
    
    failed = 0
    for test in tests:
        try:
            test()
        except AssertionError as e:
            print(f"✗ {test.__name__} failed: {e}")
            failed += 1
        except Exception as e:
            print(f"✗ {test.__name__} error: {e}")
            failed += 1
    
    print("-" * 40)
    if failed == 0:
        print(f"All {len(tests)} tests passed!")
    else:
        print(f"{failed}/{len(tests)} tests failed")
        sys.exit(1)